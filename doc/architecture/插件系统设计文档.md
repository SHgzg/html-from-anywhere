# 插件系统设计文档

## 1. 设计目标与反目标

### 1.1 插件系统必须满足（设计目标）

| 约束 | 说明 | 理由 |
|------|------|------|
| **插件不能影响启动流程** | Bootstrap 阶段不允许插件注册 | 保证启动可预测性 |
| **插件不能修改 RuntimeContext 结构** | RuntimeContext 只读 | 防止插件污染上下文 |
| **插件不能绕过 lifecycle** | 所有插件只能在指定 Phase 被调用 | 保证执行顺序可控 |
| **插件只能在明确的 Phase 被调用** | 通过 phase 字段限定 | 防止插件越界执行 |

### 1.2 插件系统明确不做（反目标）

| ❌ 不做 | 理由 |
|--------|------|
| 动态热加载 | CLI 工具不需要运行时动态性 |
| 插件之间通信 | 避免插件耦合，保持独立性 |
| 插件依赖插件 | 简化依赖管理，避免循环依赖 |
| 插件直接访问 env collection | 通过 RuntimeContext 访问，统一接口 |
| 运行时插件发现 | 编译期依赖，保证类型安全 |

**核心原则：** 插件 = 受限能力扩展点，不是自由脚本

---

## 2. 插件系统的逻辑分层

### 2.1 分层架构

```
┌─────────────────────┐
│   apps/report-cli   │  ← 插件装配层
└─────────┬───────────┘
          │ assemble
┌─────────▼───────────┐
│   lifecycle         │  ← 唯一调度者
└─────────┬───────────┘
          │ calls
┌─────────▼───────────┐
│   *-core (registry) │  ← 插件注册 & 分发
└─────────┬───────────┘
          │ execute
┌─────────▼───────────┐
│      plugins        │  ← 具体实现
└─────────────────────┘
```

### 2.2 职责划分

| 层级 | 职责 | 示例 |
|------|------|------|
| **CLI 层** | 插件装配、注册 | `import { EmailAction } from '@report/action-email'` |
| **Lifecycle 层** | 流程编排、Phase 调度 | `lifecycle.run(ctx)` |
| **Registry 层** | 插件注册、分发、校验 | `actionRegistry.get(type)` |
| **Plugin 层** | 具体实现、纯函数执行 | `EmailAction.execute(payload, ctx)` |

---

## 3. 插件的统一抽象

### 3.1 基础插件接口

```typescript
// packages/types/src/plugin.ts

/**
 * 所有插件的基础接口
 */
export interface BasePlugin {
  /** 插件名称（全局唯一） */
  name: string;

  /** 插件版本（语义化版本） */
  version: string;

  /** 兼容的 contracts 版本范围 */
  compatibleContracts: string;

  /** 插件所属的 Phase */
  phase: 'enhance' | 'data' | 'render' | 'action';
}

/**
 * Contracts 版本
 * 用于约束插件与核心系统的兼容性
 */
export const CONTRACTS_VERSION = '1.0.0';
```

### 3.2 各类型插件接口

#### Enhance Plugin

```typescript
/**
 * Enhance 插件接口
 *
 * 约束：
 * - 必须是纯函数
 * - 不能有副作用
 * - 不能修改 RuntimeContext
 * - 只能返回新的配置对象
 */
export interface EnhancePlugin extends BasePlugin {
  phase: 'enhance';

  /**
   * 应用配置增强
   * @param userConfig - 用户配置
   * @param context - 运行时上下文（只读）
   * @returns 增强后的配置
   */
  apply(
    userConfig: UserConfig,
    context: RuntimeContext
  ): UserConfig;
}
```

#### Data Plugin

```typescript
/**
 * Data 插件接口
 *
 * 约束：
 * - 只能执行数据获取操作
 * - 不能直接访问 MongoDB
 * - 失败必须抛出 DataError
 */
export interface DataPlugin extends BasePlugin {
  phase: 'data';

  /** 数据源类型标识 */
  type: DataSourceType;

  /**
   * 获取数据
   * @param config - 数据源配置
   * @param context - 运行时上下文（只读）
   * @returns 标准化的数据结果
   */
  fetch(
    config: DataItemConfig,
    context: RuntimeContext
  ): Promise<DataResult>;

  /**
   * 验证配置
   * @param config - 数据源配置
   * @returns 配置是否合法
   */
  validate(config: DataItemConfig): boolean;
}

type DataSourceType =
  | 'http'
  | 'https'
  | 'file'
  | 'inline'
  | 'glob'
  | 'db';
```

#### Render Plugin

```typescript
/**
 * Render 插件接口
 *
 * 约束：
 * - 只能执行渲染操作
 * - 不能执行 IO 操作
 * - 失败必须抛出 RenderError
 */
export interface RenderPlugin extends BasePlugin {
  phase: 'render';

  /** 渲染模式 */
  mode: RenderMode;

  /**
   * 渲染报告
   * @param data - 数据结果
   * @param config - 可执行配置
   * @param context - 运行时上下文（只读）
   * @returns 渲染结果
   */
  render(
    data: DataResult[],
    config: ExecutableConfig,
    context: RuntimeContext
  ): Promise<RenderResult>;
}
```

#### Action Plugin

```typescript
/**
 * Action 插件接口
 *
 * 约束：
 * - 只能执行副作用操作
 * - 不能修改 RuntimeContext
 * - 失败不能中断其他 Action
 */
export interface ActionPlugin extends BasePlugin {
  phase: 'action';

  /** Action 类型标识 */
  type: string;

  /**
   * 执行 Action
   * @param payload - Action 参数（已被解析）
   * @param context - 执行上下文
   * @returns void
   */
  execute(
    payload: ActionPayload,
    context: ActionContext
  ): Promise<void>;
}

/**
 * Action 执行上下文
 */
export interface ActionContext {
  /** 运行时上下文（只读） */
  readonly runtime: RuntimeContext;

  /** 数据结果（只读） */
  readonly data: DataResult[];

  /** 渲染结果（只读，可选） */
  readonly renderResult?: RenderResult;
}
```

---

## 4. Registry 设计

### 4.1 Registry 原则

| 原则 | 说明 | 实现 |
|------|------|------|
| **Registry 是映射表** | 不是工厂，不是容器 | `Map<type, Plugin>` |
| **注册期失败 > 运行期失败** | 启动时校验所有插件 | Bootstrap 阶段注册 |
| **只写一次** | Bootstrap 后只读 | `readonly` 修饰 |
| **类型安全** | 注册时校验插件类型 | TypeScript 泛型约束 |

### 4.2 通用 Registry 接口

```typescript
// packages/types/src/registry.ts

/**
 * 插件 Registry 接口
 *
 * @typeparam T - 插件类型标识
 * @typeparam P - 插件类型
 */
export interface PluginRegistry<T, P extends BasePlugin> {
  /**
   * 注册插件
   * @param plugin - 插件实例
   * @throws Error 如果插件已注册或类型不匹配
   */
  register(plugin: P): void;

  /**
   * 获取插件
   * @param type - 插件类型标识
   * @returns 插件实例
   * @throws Error 如果插件未注册
   */
  get(type: T): P;

  /**
   * 检查插件是否已注册
   * @param type - 插件类型标识
   */
  has(type: T): boolean;

  /**
   * 获取所有已注册的插件
   */
  getAll(): Map<T, P>;
}
```

### 4.3 Action Registry 实现

```typescript
// packages/action-core/src/registry.ts

import { PluginRegistry } from '@report-cli/types';
import { ActionPlugin } from '@report-cli/types';

export class ActionRegistry implements PluginRegistry<string, ActionPlugin> {
  private map = new Map<string, ActionPlugin>();

  register(plugin: ActionPlugin): void {
    // 校验插件类型
    if (plugin.phase !== 'action') {
      throw new Error(
        `Invalid plugin phase: expected 'action', got '${plugin.phase}'`
      );
    }

    // 校验版本兼容性
    if (!this.isCompatible(plugin)) {
      throw new Error(
        `Plugin ${plugin.name} is not compatible with contracts version ${CONTRACTS_VERSION}`
      );
    }

    // 防止重复注册
    if (this.map.has(plugin.type)) {
      throw new Error(`ActionPlugin type '${plugin.type}' already registered`);
    }

    this.map.set(plugin.type, plugin);
  }

  get(type: string): ActionPlugin {
    const plugin = this.map.get(type);
    if (!plugin) {
      throw new Error(`No ActionPlugin for type '${type}'`);
    }
    return plugin;
  }

  has(type: string): boolean {
    return this.map.has(type);
  }

  getAll(): Map<string, ActionPlugin> {
    return new Map(this.map);
  }

  private isCompatible(plugin: ActionPlugin): boolean {
    return semver.satisfies(
      CONTRACTS_VERSION,
      plugin.compatibleContracts
    );
  }
}
```

### 4.4 RuntimeContext 中的 Registry

```typescript
// packages/types/src/runtime.ts

export interface RuntimeContext {
  readonly envConfig: EnvConfig;
  readonly dateContext: DateContext;
  readonly cliArgs: CliArgs;

  // Registry 只读，Bootstrap 后不可修改
  readonly actionRegistry: ActionRegistry;
  readonly dataRegistry: DataRegistry;
  readonly renderRegistry: RenderRegistry;
  readonly enhanceRegistry: EnhanceRegistry;
}
```

**关键点：** `readonly` 确保插件无法替换 Registry 实例

---

## 5. 插件发现与装配

### 5.1 设计原则

| 原则 | 说明 | 实现方式 |
|------|------|----------|
| **编译期依赖** | 插件 = npm 包 | `import { EmailAction } from '@report/action-email'` |
| **显式注册** | CLI 层显式注册 | `actionRegistry.register(EmailAction)` |
| **Tree-shaking** | 未使用的插件被打包工具移除 | ES modules + static analysis |
| **类型安全** | 编译时检查插件接口 | TypeScript 类型检查 |

### 5.2 CLI 层插件装配

```typescript
// apps/report-cli/src/plugins.ts

import { actionRegistry } from './context/registries';
import { EmailAction } from '@report/action-email';
import { StorageAction } from '@report/action-storage';
import { NotificationAction } from '@report/action-notification';

/**
 * 注册所有内置插件
 *
 * 注意：这是在 Bootstrap 阶段执行的
 * RuntimeContext 构建完成后，不再允许注册
 */
export function registerBuiltinPlugins(): void {
  // 注册 Action 插件
  actionRegistry.register(EmailAction);
  actionRegistry.register(StorageAction);
  actionRegistry.register(NotificationAction);

  // 注册 Data 插件
  // dataRegistry.register(HttpDataSource);
  // dataRegistry.register(FileDataSource);

  // 注册 Render 插件
  // renderRegistry.register(HtmlRenderer);
  // renderRegistry.register(EmailRenderer);

  // 注册 Enhance 插件
  // enhanceRegistry.register(DefaultHttpEnhance);
}
```

### 5.3 Bootstrap 阶段插件初始化

```typescript
// packages/bootstrap/src/index.ts

import { registerBuiltinPlugins } from '@report-cli/plugins';

export async function bootstrap(): Promise<RuntimeContext> {
  // 1. 加载 .env
  const envConfig = loadEnvConfig();

  // 2. 连接 MongoDB
  const db = await connectToMongoDB(envConfig);

  // 3. 加载 env collection
  const envCollection = await loadEnvCollection(db);

  // 4. 解析 CLI 参数
  const cliArgs = parseCliArgs();

  // 5. 构建 DateContext
  const dateContext = buildDateContext(cliArgs.date);

  // 6. 注册所有插件
  // ⚠️ 关键：在 RuntimeContext 构建之前完成注册
  const registries = createRegistries();
  registerBuiltinPlugins(registries);

  // 7. 构建 RuntimeContext
  const runtime: RuntimeContext = {
    envConfig: envCollection,
    dateContext,
    cliArgs,
    ...registries
  };

  return runtime;
}
```

---

## 6. 插件与配置的绑定

### 6.1 绑定原则

**插件永远不解析原始配置**

- 配置解析由 Config Phase 负责
- 插件只接收"已被解析过的 payload"
- 插件不关心配置来自哪里

### 6.2 Lifecycle 调度插件

```typescript
// packages/lifecycle/src/phases/action.ts

export async function executeActionPhase(
  config: ExecutableConfig,
  runtime: RuntimeContext,
  dataResults: DataResult[],
  renderResults: Map<RenderMode, RenderResult>
): Promise<void> {
  // 按事件分组
  const actionsByEvent = groupByEvent(config.actions);

  // 执行 data_ready 事件
  await executeActions('data_ready', actionsByEvent.data_ready, {
    runtime,
    data: dataResults
  });

  // 执行 report_ready 事件
  await executeActions('report_ready', actionsByEvent.report_ready, {
    runtime,
    data: dataResults,
    renderResult: renderResults.get('html')
  });

  // 执行 report_archived 事件
  await executeActions('report_archived', actionsByEvent.report_archived, {
    runtime,
    data: dataResults
  });
}

async function executeActions(
  event: string,
  actions: ActionConfig[],
  context: ActionContext
): Promise<void> {
  for (const actionConfig of actions) {
    const plugin = runtime.actionRegistry.get(actionConfig.type);

    try {
      // ✅ 插件只接收已被解析的 payload
      await plugin.execute(actionConfig.spec, context);
    } catch (error) {
      // Action 错误不中断其他 Action
      logger.error(`Action failed: ${actionConfig.type}`, { error });
    }
  }
}
```

---

## 7. 版本与兼容性策略

### 7.1 Contracts 版本

```typescript
// packages/types/src/contracts.ts

/**
 * Contracts 版本定义
 *
 * 主版本号：接口不兼容变更
 * 次版本号：向后兼容的功能新增
 * 修订号：向后兼容的问题修复
 */
export const CONTRACTS_VERSION = '1.0.0';

/**
 * SemVer 版本范围
 */
export type SemVerRange = string;
```

### 7.2 插件版本声明

```typescript
export interface BasePlugin {
  name: string;
  version: string;                      // 插件自身版本
  compatibleContracts: SemVerRange;     // 兼容的 contracts 版本
  phase: PluginPhase;
}
```

### 7.3 版本校验

```typescript
// packages/bootstrap/src/plugin-validator.ts

import semver from 'semver';
import { CONTRACTS_VERSION } from '@report-cli/types';

export function validatePluginCompatibility(
  plugin: BasePlugin
): boolean {
  return semver.satisfies(
    CONTRACTS_VERSION,
    plugin.compatibleContracts
  );
}

export function assertPluginCompatibility(plugin: BasePlugin): void {
  if (!validatePluginCompatibility(plugin)) {
    throw new Error(
      `Plugin '${plugin.name}' (v${plugin.version}) is not compatible ` +
      `with contracts version ${CONTRACTS_VERSION}. ` +
      `Plugin requires: ${plugin.compatibleContracts}`
    );
  }
}
```

### 7.4 版本兼容性矩阵示例

| 插件版本 | Contracts 版本 | 兼容性 |
|----------|----------------|--------|
| 1.0.0 | ^1.0.0 | ✅ 兼容 |
| 1.2.0 | ^1.0.0 | ✅ 兼容 |
| 2.0.0 | ^1.0.0 | ❌ 不兼容 |
| 1.0.0 | ^2.0.0 | ❌ 不兼容 |

---

## 8. 插件约束校验

### 8.1 启动时校验

```typescript
// packages/bootstrap/src/plugin-validator.ts

export interface PluginValidationResult {
  isValid: boolean;
  errors: string[];
}

export function validatePlugin(plugin: BasePlugin): PluginValidationResult {
  const errors: string[] = [];

  // 1. 校验插件名称
  if (!plugin.name || plugin.name.trim() === '') {
    errors.push('Plugin name is required');
  }

  // 2. 校验版本格式
  if (!semver.valid(plugin.version)) {
    errors.push(`Invalid plugin version: ${plugin.version}`);
  }

  // 3. 校验 contracts 兼容性
  if (!validatePluginCompatibility(plugin)) {
    errors.push(
      `Plugin not compatible with contracts version ${CONTRACTS_VERSION}`
    );
  }

  // 4. 校验 phase 约束
  if (!['enhance', 'data', 'render', 'action'].includes(plugin.phase)) {
    errors.push(`Invalid plugin phase: ${plugin.phase}`);
  }

  // 5. 校验类型特定的约束
  if (plugin.phase === 'action') {
    const actionPlugin = plugin as ActionPlugin;
    if (!actionPlugin.type) {
      errors.push('Action plugin must have a type');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}
```

### 8.2 Registry 中的校验

```typescript
export class ActionRegistry {
  register(plugin: ActionPlugin): void {
    // 启动时完整校验
    const validation = validatePlugin(plugin);
    if (!validation.isValid) {
      throw new Error(
        `Plugin validation failed for '${plugin.name}':\n` +
        validation.errors.map(e => `  - ${e}`).join('\n')
      );
    }

    // 防止重复注册
    if (this.map.has(plugin.type)) {
      throw new Error(`ActionPlugin type '${plugin.type}' already registered`);
    }

    this.map.set(plugin.type, plugin);
  }
}
```

---

## 9. 完整示例

### 9.1 Email Action 插件

```typescript
// packages/action-email/src/index.ts

import { ActionPlugin, ActionContext, ActionPayload } from '@report-cli/types';
import { CONTRACTS_VERSION } from '@report-cli/types';

/**
 * Email Action 插件
 *
 * 职责：发送邮件通知或报告
 */
export const EmailAction: ActionPlugin = {
  name: 'email-action',
  version: '1.0.0',
  compatibleContracts: '^1.0.0',
  phase: 'action',
  type: 'email',

  async execute(payload: ActionPayload, context: ActionContext): Promise<void> {
    // ✅ 只能通过 context 访问数据，不能修改
    const { renderResult } = context;

    if (!renderResult) {
      throw new Error('Email action requires a render result');
    }

    // ✅ 提取配置（已被解析）
    const to = payload.to as string[];
    const subject = payload.subject as string;
    const body = renderResult.content;

    // ✅ 执行副作用操作
    await sendEmail({ to, subject, body });
  }
};

async function sendEmail(options: EmailOptions): Promise<void> {
  // 实现邮件发送逻辑
}
```

### 9.2 注册与运行

```typescript
// apps/report-cli/src/index.ts

import { bootstrap } from '@report-cli/bootstrap';
import { lifecycle } from '@report-cli/lifecycle';
import { actionRegistry } from './context/registries';
import { EmailAction } from '@report/action-email';

async function main() {
  // 1. Bootstrap: 注册所有插件
  const runtime = await bootstrap();
  actionRegistry.register(EmailAction);

  // 2. 运行生命周期
  await lifecycle.run(runtime);
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

---

## 10. 插件开发指南

### 10.1 创建新插件步骤

1. **创建插件包**
   ```bash
   pnpm create @report/cli-plugin my-action
   ```

2. **实现插件接口**
   ```typescript
   export const MyAction: ActionPlugin = {
     name: 'my-action',
     version: '1.0.0',
     compatibleContracts: '^1.0.0',
     phase: 'action',
     type: 'my-action',

     async execute(payload, context) {
       // 实现逻辑
     }
   };
   ```

3. **在 CLI 中注册**
   ```typescript
   import { MyAction } from '@report/action-my';
   actionRegistry.register(MyAction);
   ```

4. **在配置中使用**
   ```json
   {
     "actions": [
       {
         "type": "my-action",
         "on": "report_ready",
         "spec": { /* 参数 */ }
       }
     ]
   }
   ```

### 10.2 插件最佳实践

| 最佳实践 | 说明 |
|----------|------|
| **纯函数** | 插件应该是无状态的纯函数 |
| **错误处理** | 插件应该捕获并处理自己的错误 |
| **日志输出** | 使用统一的日志接口 |
| **性能优化** | 避免长时间阻塞操作 |
| **测试覆盖** | 提供完整的单元测试 |

---

## 11. 插件系统防腐层

### 11.1 防腐措施

| 措施 | 实现方式 | 防护目标 |
|------|----------|----------|
| **类型系统** | TypeScript 接口 | 编译时类型检查 |
| **readonly Registry** | RuntimeContext 只读 | 运行时不可替换 |
| **Phase 约束** | plugin.phase 字段 | 防止越界执行 |
| **版本校验** | semver 兼容性检查 | 防止不兼容插件 |
| **注册期校验** | Bootstrap 阶段完整校验 | 启动时发现问题 |
| **显式注册** | CLI 层 import 并注册 | 编译期依赖 |

### 11.2 错误边界

```typescript
// 确保插件错误不会污染主流程

try {
  await plugin.execute(payload, context);
} catch (error) {
  // ✅ 记录错误
  logger.error(`Plugin ${plugin.name} failed`, { error });

  // ✅ 不中断其他插件
  // ✅ 不修改 RuntimeContext
  // ✅ 不影响生命周期

  // ⚠️ 如果是关键错误，标记失败状态
  if (error.level === 'critical') {
    failures.push({ plugin, error });
  }
}
```

---

## 12. 核心原则总结

> **插件系统的成功，不在于"能不能扩展"，而在于"不让错误的扩展进来"。**

你现在做的：
- ✅ readonly registry
- ✅ phase 限制
- ✅ 显式注册
- ✅ contracts 版本约束

全部都是高级工程系统才会有的"防腐层"。

---

## 13. 本文档边界声明

本文档 **不负责**：
- 插件的具体实现逻辑
- 插件的打包和分发
- 插件的测试策略

它只负责：
> **定义插件系统的架构、接口、约束和版本兼容性策略**

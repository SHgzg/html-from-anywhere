# 错误处理与重试策略文档

## 1. 设计目标

本文档用于定义 **Report CLI 的错误分类、处理策略和重试机制**。

目标是：
- 统一的错误分类和错误码
- 明确的错误处理流程
- 智能的重试策略
- 友好的错误提示

---

## 2. 错误分类体系

### 2.1 错误类型定义

```typescript
enum ErrorCategory {
  // 配置错误
  CONFIG_ERROR = 'CONFIG_ERROR',

  // 数据源错误
  DATA_SOURCE_ERROR = 'DATA_SOURCE_ERROR',

  // 渲染错误
  RENDER_ERROR = 'RENDER_ERROR',

  // Action 错误
  ACTION_ERROR = 'ACTION_ERROR',

  // 系统错误
  SYSTEM_ERROR = 'SYSTEM_ERROR'
}

enum ErrorCode {
  // 配置错误 (1xxx)
  CONFIG_FILE_NOT_FOUND = 1001,
  CONFIG_PARSE_ERROR = 1002,
  CONFIG_VALIDATE_ERROR = 1003,
  CONFIG_DEPRECATED = 1004,
  ENHANCE_NOT_FOUND = 1005,
  ENHANCE_APPLY_ERROR = 1006,

  // 数据源错误 (2xxx)
  DATA_SOURCE_TIMEOUT = 2001,
  DATA_SOURCE_HTTP_ERROR = 2002,
  DATA_SOURCE_PARSE_ERROR = 2003,
  DATA_SOURCE_NOT_FOUND = 2004,
  DATA_SOURCE_PERMISSION_DENIED = 2005,
  DATA_SOURCE_CONNECTION_ERROR = 2006,

  // 渲染错误 (3xxx)
  RENDER_TEMPLATE_NOT_FOUND = 3001,
  RENDER_COMPILE_ERROR = 3002,
  RENDER_EXECUTE_ERROR = 3003,

  // Action 错误 (4xxx)
 _ACTION_EXECUTION_ERROR = 4001,
  ACTION_TIMEOUT = 4002,
  ACTION_VALIDATE_ERROR = 4003,

  // 系统错误 (5xxx)
  SYSTEM_DB_CONNECTION_ERROR = 5001,
  SYSTEM_DB_QUERY_ERROR = 5002,
  SYSTEM_OUT_OF_MEMORY = 5003,
  SYSTEM_UNKNOWN_ERROR = 5099
}
```

### 2.2 错误对象结构

```typescript
class ReportCliError extends Error {
  category: ErrorCategory;
  code: ErrorCode;
  message: string;
  details: Record<string, unknown>;
  retryable: boolean;
  suggestion?: string;

  constructor(config: {
    code: ErrorCode;
    message: string;
    details?: Record<string, unknown>;
    retryable?: boolean;
    suggestion?: string;
  }) {
    super(message);
    this.name = 'ReportCliError';
    this.code = config.code;
    this.category = this.getCategory(config.code);
    this.message = config.message;
    this.details = config.details || {};
    this.retryable = config.retryable || false;
    this.suggestion = config.suggestion;
  }

  private getCategory(code: ErrorCode): ErrorCategory {
    const codeNum = parseInt(code.toString());
    if (codeNum >= 1000 && codeNum < 2000) return ErrorCategory.CONFIG_ERROR;
    if (codeNum >= 2000 && codeNum < 3000) return ErrorCategory.DATA_SOURCE_ERROR;
    if (codeNum >= 3000 && codeNum < 4000) return ErrorCategory.RENDER_ERROR;
    if (codeNum >= 4000 && codeNum < 5000) return ErrorCategory.ACTION_ERROR;
    return ErrorCategory.SYSTEM_ERROR;
  }
}
```

---

## 3. 各模块错误处理

### 3.1 Bootstrap Phase

#### 错误类型

| 错误码 | 说明 | 是否重试 | 处理方式 |
|--------|------|----------|----------|
| 1001 | .env 文件不存在 | ❌ | 立即退出 |
| 5001 | MongoDB 连接失败 | ✅ (3次) | 重试后失败则退出 |
| 1002 | env_collection 加载失败 | ❌ | 立即退出 |

#### 示例

```typescript
// MongoDB 连接重试
async function connectToMongoDB(config: MongoConfig): Promise<MongoClient> {
  let lastError: Error;
  for (let i = 0; i < 3; i++) {
    try {
      return await MongoClient.connect(config.uri, {
        serverSelectionTimeoutMS: 5000,
        connectTimeoutMS: 5000
      });
    } catch (error) {
      lastError = error;
      logger.warn(`MongoDB connection failed (attempt ${i + 1}/3)`, {
        error: error.message
      });
      await sleep(1000 * (i + 1));  // 指数退避
    }
  }

  throw new ReportCliError({
    code: ErrorCode.SYSTEM_DB_CONNECTION_ERROR,
    message: 'Failed to connect to MongoDB after 3 attempts',
    details: { error: lastError.message },
    retryable: false,
    suggestion: 'Please check MongoDB server status and connection string'
  });
}
```

### 3.2 Config Phase

#### 错误类型

| 错误码 | 说明 | 是否重试 | 处理方式 |
|--------|------|----------|----------|
| 1001 | user_config 文件不存在 | ❌ | 立即退出 |
| 1002 | user_config JSON 解析失败 | ❌ | 立即退出 |
| 1003 | user_config 验证失败 | ❌ | 立即退出 |
| 1004 | 配置已废弃 | ❌ | 警告并继续 |
| 1005 | enhance_config 未找到 | ❌ | 立即退出 |
| 1006 | enhance 应用失败 | ❌ | 立即退出 |

#### 示例

```typescript
function loadUserConfig(path: string): UserConfig {
  if (!fs.existsSync(path)) {
    throw new ReportCliError({
      code: ErrorCode.CONFIG_FILE_NOT_FOUND,
      message: `Config file not found: ${path}`,
      details: { path },
      retryable: false,
      suggestion: 'Please check the file path or create a config file'
    });
  }

  try {
    const content = fs.readFileSync(path, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    throw new ReportCliError({
      code: ErrorCode.CONFIG_PARSE_ERROR,
      message: 'Failed to parse config file',
      details: { path, error: error.message },
      retryable: false,
      suggestion: 'Please check JSON syntax in config file'
    });
  }
}
```

### 3.3 Data Phase

#### 错误类型

| 错误码 | 说明 | 是否重试 | 处理方式 |
|--------|------|----------|----------|
| 2001 | 数据源请求超时 | ✅ (3次) | 重试后失败则终止 |
| 2002 | HTTP 错误 | 部分重试 | 见 HTTP 重试规则 |
| 2003 | 数据解析失败 | ❌ | 记录并终止 |
| 2004 | 文件不存在 | ❌ | 立即终止 |
| 2005 | 权限不足 | ❌ | 立即终止 |
| 2006 | 数据库连接失败 | ✅ (3次) | 重试后失败则终止 |

#### HTTP 错误重试规则

```typescript
const RETRYABLE_HTTP_STATUS = [408, 429, 500, 502, 503, 504];

function shouldRetryHttpError(status: number): boolean {
  return RETRYABLE_HTTP_STATUS.includes(status);
}
```

#### 示例

```typescript
async function fetchHttpData(source: HttpSource): Promise<unknown> {
  const maxRetries = source.retries || 3;
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await axios({
        method: source.method || 'GET',
        url: source.url,
        timeout: source.timeout || 30000,
        headers: source.headers
      });

      return response.data;
    } catch (error) {
      lastError = error;

      if (!shouldRetryHttpError(error.response?.status)) {
        break;  // 不可重试的错误
      }

      if (attempt < maxRetries) {
        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
        logger.debug(`Retrying HTTP request (${attempt}/${maxRetries})`, {
          url: source.url,
          delay
        });
        await sleep(delay);
      }
    }
  }

  throw new ReportCliError({
    code: ErrorCode.DATA_SOURCE_TIMEOUT,
    message: `HTTP request failed after ${maxRetries} attempts`,
    details: {
      url: source.url,
      error: lastError.message
    },
    retryable: false,
    suggestion: 'Please check data source availability and network connection'
  });
}
```

### 3.4 Render Phase

#### 错误类型

| 错误码 | 说明 | 是否重试 | 处理方式 |
|--------|------|----------|----------|
| 3001 | 模板文件不存在 | ❌ | 记录并跳过 |
| 3002 | 模板编译失败 | ❌ | 记录并终止 |
| 3003 | 模板执行失败 | ❌ | 记录并终止 |

#### 处理策略

- **单个渲染模式失败**：只影响依赖该模式的 Action
- **所有渲染模式失败**：终止 Render Phase
- **模板不存在**：使用默认模板或降级处理

#### 示例

```typescript
try {
  const html = await renderTemplate('custom.html', data);
} catch (error) {
  logger.warn('Custom template failed, falling back to default', {
    error: error.message
  });

  try {
    const html = await renderTemplate('default.html', data);
  } catch (fallbackError) {
    throw new ReportCliError({
      code: ErrorCode.RENDER_EXECUTE_ERROR,
      message: 'All render attempts failed',
      details: {
        customError: error.message,
        fallbackError: fallbackError.message
      },
      retryable: false,
      suggestion: 'Please check template syntax and data structure'
    });
  }
}
```

### 3.5 Action Phase

#### 错误类型

| 错误码 | 说明 | 是否重试 | 处理方式 |
|--------|------|----------|----------|
| 4001 | Action 执行失败 | ❌ | 记录并继续 |
| 4002 | Action 超时 | ❌ | 记录并继续 |
| 4003 | Action spec 验证失败 | ❌ | 记录并跳过 |

#### 处理策略

- **单个 Action 失败**：不中断其他 Action
- **错误记录**：记录到日志和执行摘要
- **失败通知**：触发 notification action（如配置）

#### 示例

```typescript
async function executeAction(action: ActionConfig, context: ActionContext): Promise<void> {
  try {
    const executor = actionRegistry.get(action.type);
    await executor.execute(action, context);
    logger.info(`Action executed: ${action.type}`);
  } catch (error) {
    logger.error(`Action failed: ${action.type}`, {
      error: error.message,
      spec: redactSensitive(action.spec)
    });

    // 触发失败通知（如果配置了 notification action）
    await emitActionFailedEvent(action, error);

    // 不中断其他 action
  }
}
```

---

## 4. 重试策略

### 4.1 指数退避

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries: number;
    baseDelay: number;
    maxDelay: number;
  }
): Promise<T> {
  const { maxRetries, baseDelay, maxDelay } = options;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
      logger.debug(`Retrying after ${delay}ms (attempt ${attempt}/${maxRetries})`);
      await sleep(delay);
    }
  }

  throw new Error('Max retries exceeded');
}
```

### 4.2 重试配置

```typescript
interface RetryConfig {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
  retryableErrors: ErrorCode[];
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
  retryableErrors: [
    ErrorCode.DATA_SOURCE_TIMEOUT,
    ErrorCode.DATA_SOURCE_HTTP_ERROR,
    ErrorCode.SYSTEM_DB_CONNECTION_ERROR
  ]
};
```

---

## 5. 错误信息规范

### 5.1 错误信息格式

```
错误: <简短描述>

详情:
  - 错误码: <CODE>
  - 类别: <CATEGORY>
  - 消息: <详细消息>

上下文:
  - <key1>: <value1>
  - <key2>: <value2>

建议:
  <解决建议>

使用 --help 查看帮助信息
```

### 5.2 示例

```
错误: 数据源请求失败

详情:
  - 错误码: 2001 (DATA_SOURCE_TIMEOUT)
  - 类别: DATA_SOURCE_ERROR
  - 消息: HTTP request timeout after 30000ms

上下文:
  - 数据源: 用户数据
  - URL: https://api.example.com/users
  - 超时设置: 30000ms
  - 重试次数: 3

建议:
  1. 检查数据源服务是否正常运行
  2. 检查网络连接
  3. 增加 timeout 配置
  4. 检查是否需要 API 密钥

使用 --help 查看帮助信息
```

---

## 6. Notification Action

### 6.1 设计目的

Action 失败后发送通知，让运维人员及时了解问题。

### 6.2 触发条件

- Action 执行失败
- Action 超时
- Data Phase 失败
- Render Phase 失败

### 6.3 配置示例

```json
{
  "type": "notification",
  "on": "action_failed",
  "spec": {
    "channels": ["email", "webhook"],
    "condition": "error.level === 'critical'",
    "template": "action_error_notification",
    "recipients": {
      "email": ["ops@example.com"],
      "webhook": ["https://hooks.example.com/alerts"]
    }
  }
}
```

### 6.4 通知内容

```json
{
  "title": "Report CLI Action Failed",
  "severity": "critical",
  "timestamp": "2025-01-30T10:30:00Z",
  "reportId": "daily_report",
  "action": {
    "type": "email",
    "on": "report_ready"
  },
  "error": {
    "code": 4001,
    "message": "Failed to send email",
    "details": {
      "smtp": "smtp.example.com",
      "port": 587
    }
  }
}
```

---

## 7. 错误恢复策略

### 7.1 降级处理

| 场景 | 降级策略 |
|------|----------|
| 自定义模板失败 | 使用默认模板 |
| 主数据源失败 | 使用备用数据源 |
| Email 发送失败 | 尝试备用 SMTP 服务器 |

### 7.2 断路器模式

```typescript
class CircuitBreaker {
  private failureCount = 0;
  private lastFailureTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > 60000) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }

    try {
      const result = await fn();
      if (this.state === 'half-open') {
        this.state = 'closed';
        this.failureCount = 0;
      }
      return result;
    } catch (error) {
      this.failureCount++;
      this.lastFailureTime = Date.now();

      if (this.failureCount >= 5) {
        this.state = 'open';
      }

      throw error;
    }
  }
}
```

---

## 8. 错误监控与告警

### 8.1 错误统计

```typescript
interface ErrorStats {
  totalErrors: number;
  errorsByCategory: Record<ErrorCategory, number>;
  errorsByCode: Record<ErrorCode, number>;
  recentErrors: ErrorLog[];
}

function collectErrorStats(): ErrorStats {
  // 收集错误统计信息
}
```

### 8.2 告警规则

| 条件 | 级别 | 处理方式 |
|------|------|----------|
| 单次致命错误 | critical | 立即通知 |
| 10 分钟内 > 5 个错误 | high | 发送摘要 |
| 1 小时内 > 20 个错误 | medium | 记录日志 |

---

## 9. 本文档边界声明

本文档 **不负责**：
- 具体的错误监控实现
- 告警系统的搭建

它只负责：
> **定义错误分类、处理策略、重试规则和错误信息格式**

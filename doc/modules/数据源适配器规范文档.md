# 数据源适配器规范文档

## 1. 设计目标

本文档用于定义 **数据源适配器的统一接口、行为规范和错误处理策略**。

目标是：
- 统一不同数据源的访问方式
- 规范适配器的实现契约
- 确保数据获取的可靠性和可预测性
- 支持灵活的数据源扩展

---

## 2. 数据源类型总览

系统支持以下数据源类型：

| 类型 | 标识符 | 描述 | 示例 |
|------|--------|------|------|
| HTTP | `http` / `https` | 从 HTTP/HTTPS 端点获取数据 | `"https://api.example.com/users"` |
| File | `file` | 从本地文件读取数据 | `"/data/users.json"` |
| Inline JSON | `inline` | 内联 JSON 字符串 | `"[{\"id\":1}]"` |
| Glob | `glob` | 文件模式匹配 | `{"value": "/data", "pattern": "*.csv"}` |
| Database | `db` | 从数据库查询 | `{"type": "mongodb", "collection": "users"}` |

---

## 3. DataSourceAdapter 接口定义

### 3.1 TypeScript 接口

```typescript
interface DataSourceAdapter {
  /**
   * 适配器类型标识符
   */
  type: string;

  /**
   * 从数据源获取数据
   * @param source - 数据源配置
   * @param context - 运行时上下文
   * @returns 原始数据
   * @throws DataSourceError 当获取失败时
   */
  fetch(
    source: unknown,
    context: RuntimeContext
  ): Promise<unknown>;

  /**
   * 验证数据源配置是否合法
   * @param source - 数据源配置
   * @returns true 如果配置合法
   */
  validate(source: unknown): boolean;

  /**
   * 获取适配器的元信息
   */
  getMetadata(): AdapterMetadata;
}

interface AdapterMetadata {
  type: string;
  name: string;
  description: string;
  version: string;
  supportedFormats: string[];
}
```

### 3.2 接口约束

- **纯函数行为**：相同输入必须产生相同输出
- **幂等性**：多次调用结果一致
- **无副作用**：不修改输入参数
- **错误透明**：失败时抛出 DataSourceError

---

## 4. 各数据源适配器详细规范

### 4.1 HTTP 数据源适配器

#### 4.1.1 source 配置格式

```typescript
// 简单字符串格式
type HttpSourceSimple = string;  // "https://api.example.com/users"

// 对象格式
interface HttpSourceObject {
  type: 'http' | 'https';
  url: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  headers?: Record<string, string>;
  params?: Record<string, string>;
  body?: unknown;
  timeout?: number;       // 毫秒
  retries?: number;       // 重试次数
  responseType?: 'json' | 'text' | 'blob';
  auth?: {
    type: 'basic' | 'bearer' | 'custom';
    username?: string;   // basic auth
    password?: string;   // basic auth
    token?: string;      // bearer auth
  };
}
```

#### 4.1.2 行为规范

| 特性 | 默认值 | 说明 |
|------|--------|------|
| method | GET | HTTP 方法 |
| timeout | 30000 | 30 秒超时 |
| retries | 3 | 失败重试 3 次 |
| responseType | json | 自动解析 JSON |

#### 4.1.3 错误处理

```typescript
// 超时错误
throw new DataSourceError({
  type: 'TIMEOUT',
  message: 'HTTP request timeout',
  source: 'https://api.example.com/users',
  details: { timeout: 30000, elapsed: 30001 }
});

// HTTP 错误
throw new DataSourceError({
  type: 'HTTP_ERROR',
  message: 'HTTP request failed',
  source: 'https://api.example.com/users',
  details: { status: 404, statusText: 'Not Found' }
});

// 解析错误
throw new DataSourceError({
  type: 'PARSE_ERROR',
  message: 'Failed to parse JSON response',
  source: 'https://api.example.com/users',
  details: { error: 'Unexpected token < in JSON at position 0' }
});
```

#### 4.1.4 重试策略

| 状态码 | 是否重试 | 说明 |
|--------|----------|------|
| 408 | ✅ | Request Timeout |
| 429 | ✅ | Too Many Requests |
| 500 | ✅ | Internal Server Error |
| 502 | ✅ | Bad Gateway |
| 503 | ✅ | Service Unavailable |
| 504 | ✅ | Gateway Timeout |
| 4xx (其他) | ❌ | 客户端错误，不重试 |
| 5xx (其他) | ❌ | 服务器错误，不重试 |

重试间隔：指数退避（1s, 2s, 4s...）

---

### 4.2 File 数据源适配器

#### 4.2.1 source 配置格式

```typescript
// 简单字符串格式
type FileSourceSimple = string;  // "/data/users.json"

// 对象格式
interface FileSourceObject {
  type: 'file';
  path: string;
  encoding?: BufferEncoding;  // 默认 'utf-8'
  format?: 'json' | 'csv' | 'txt' | 'xml';
}
```

#### 4.2.2 行为规范

| 特性 | 默认值 | 说明 |
|------|--------|------|
| encoding | utf-8 | 文件编码 |
| format | auto | 根据扩展名自动识别 |

#### 4.2.3 支持的文件格式

| 格式 | 扩展名 | 解析方式 |
|------|--------|----------|
| JSON | .json | JSON.parse |
| CSV | .csv | csv-parse |
| XML | .xml | xml2js |
| TXT | .txt | 原始文本 |

#### 4.2.4 错误处理

```typescript
// 文件不存在
throw new DataSourceError({
  type: 'FILE_NOT_FOUND',
  message: 'File not found',
  source: '/data/users.json',
  details: { path: '/data/users.json' }
});

// 权限错误
throw new DataSourceError({
  type: 'PERMISSION_DENIED',
  message: 'Permission denied',
  source: '/data/users.json',
  details: { path: '/data/users.json', code: 'EACCES' }
});
```

---

### 4.3 Inline JSON 数据源适配器

#### 4.3.1 source 配置格式

```typescript
// 字符串格式（已经是 JSON）
type InlineSourceSimple = string;  // '[{"id":1},{"id":2}]'

// 对象格式
interface InlineSourceObject {
  type: 'inline';
  data: string | unknown;
  format?: 'json' | 'raw';
}
```

#### 4.3.2 行为规范

- **自动解析**：尝试 JSON.parse，失败则返回原始字符串
- **无 IO 操作**：纯内存操作
- **无错误重试**：解析失败立即报错

#### 4.3.3 错误处理

```typescript
throw new DataSourceError({
  type: 'PARSE_ERROR',
  message: 'Failed to parse inline JSON',
  source: '<inline>',
  details: { error: 'Unexpected token' }
});
```

---

### 4.4 Glob 数据源适配器

#### 4.4.1 source 配置格式

```typescript
interface GlobSource {
  type: 'glob';
  value: string;      // 基础路径
  pattern: string;    // glob 模式
  encoding?: BufferEncoding;
  format?: 'json' | 'csv' | 'txt';
  sort?: 'alpha' | 'mtime';  // 排序方式
  mergeStrategy?: 'concat' | 'merge' | 'array';  // 合并策略
}
```

#### 4.4.2 行为规范

| 特性 | 默认值 | 说明 |
|------|--------|------|
| sort | alpha | 按文件名排序 |
| mergeStrategy | concat | 数组拼接 |
| encoding | utf-8 | 文件编码 |

#### 4.4.3 合并策略示例

```json
// concat (默认)
[
  {"file": "a.csv", "data": [{"id":1}]},
  {"file": "b.csv", "data": [{"id":2}]}
]

// merge
{"a.csv": [{"id":1}], "b.csv": [{"id":2}]}

// array
[[{"id":1}], [{"id":2}]]
```

#### 4.4.4 错误处理

```typescript
// 无匹配文件
throw new DataSourceError({
  type: 'NO_MATCH',
  message: 'No files matched the pattern',
  source: { value: '/data', pattern: '*.csv' },
  details: { pattern: '/data/*.csv' }
});
```

---

### 4.5 Database 数据源适配器（可选）

#### 4.5.1 source 配置格式

```typescript
interface DatabaseSource {
  type: 'db';
  dbType: 'mongodb' | 'mysql' | 'postgresql';
  connection: {
    uri?: string;        // 连接字符串
    host?: string;
    port?: number;
    database: string;
    username?: string;
    password?: string;
  };
  query: {
    collection?: string;  // MongoDB collection
    table?: string;        // SQL table
    filter?: Record<string, unknown>;
    projection?: Record<string, number>;
    limit?: number;
    sort?: Record<string, 1 | -1>;
  };
}
```

#### 4.5.2 行为规范

- **连接复用**：复用 RuntimeContext 中的 DB 连接
- **查询超时**：默认 30 秒
- **结果限制**：默认最多 10000 条记录

#### 4.5.3 错误处理

```typescript
// 连接错误
throw new DataSourceError({
  type: 'CONNECTION_ERROR',
  message: 'Failed to connect to database',
  source: { dbType: 'mongodb', database: 'test' },
  details: { error: 'Connection timeout' }
});

// 查询错误
throw new DataSourceError({
  type: 'QUERY_ERROR',
  message: 'Query execution failed',
  source: { collection: 'users' },
  details: { error: 'Invalid query syntax' }
});
```

---

## 5. DataSourceError 规范

### 5.1 错误类型定义

```typescript
interface DataSourceError {
  type: ErrorType;
  message: string;
  source: unknown;
  details?: Record<string, unknown>;
  retryable?: boolean;
}

type ErrorType =
  | 'TIMEOUT'           // 请求超时
  | 'HTTP_ERROR'        // HTTP 错误
  | 'PARSE_ERROR'       // 解析错误
  | 'FILE_NOT_FOUND'    // 文件不存在
  | 'PERMISSION_DENIED' // 权限错误
  | 'CONNECTION_ERROR'  // 连接错误
  | 'QUERY_ERROR'       // 查询错误
  | 'NO_MATCH'          // 无匹配文件
  | 'INVALID_SOURCE'    // 无效的数据源配置
  | 'UNKNOWN';          // 未知错误
```

### 5.2 错误处理策略

| 错误类型 | 是否重试 | 阶段处理 |
|----------|----------|----------|
| TIMEOUT | ✅ | 重试 3 次 |
| HTTP_ERROR (5xx) | ✅ | 重试 3 次 |
| HTTP_ERROR (4xx) | ❌ | 立即终止 |
| PARSE_ERROR | ❌ | 立即终止 |
| FILE_NOT_FOUND | ❌ | 立即终止 |
| PERMISSION_DENIED | ❌ | 立即终止 |
| CONNECTION_ERROR | ✅ | 重试 3 次 |
| QUERY_ERROR | ❌ | 立即终止 |
| NO_MATCH | ❌ | 立即终止 |
| INVALID_SOURCE | ❌ | 立即终止 |

---

## 6. 适配器注册与发现

### 6.1 适配器注册

```typescript
class DataSourceRegistry {
  private adapters = new Map<string, DataSourceAdapter>();

  register(adapter: DataSourceAdapter): void {
    this.adapters.set(adapter.type, adapter);
  }

  get(type: string): DataSourceAdapter {
    const adapter = this.adapters.get(type);
    if (!adapter) {
      throw new Error(`Unknown data source type: ${type}`);
    }
    return adapter;
  }

  has(type: string): boolean {
    return this.adapters.has(type);
  }
}
```

### 6.2 自动类型推断

```typescript
function detectSourceType(source: unknown): string {
  if (typeof source === 'string') {
    if (source.startsWith('http://') || source.startsWith('https://')) {
      return 'http';
    }
    if (source.startsWith('/') || source.startsWith('./')) {
      return 'file';
    }
    // 尝试解析为 inline JSON
    try {
      JSON.parse(source);
      return 'inline';
    } catch {
      return 'inline';  // raw string
    }
  }

  if (typeof source === 'object' && source !== null) {
    const obj = source as Record<string, unknown>;
    return obj.type as string;
  }

  throw new DataSourceError({
    type: 'INVALID_SOURCE',
    message: 'Cannot detect data source type',
    source
  });
}
```

---

## 7. DataResult 标准化

### 7.1 DataResult 结构

```typescript
interface DataResult {
  title: string;           // 数据项标题
  tag: string;            // 数据类型标识
  data: unknown;          // 原始数据
  meta?: {
    sourceType: string;   // 数据源类型
    source: unknown;      // 原始数据源配置
    rowCount?: number;    // 行数（数组数据）
    warnings?: string[];  // 警告信息
    elapsed?: number;     // 获取耗时（毫秒）
    [key: string]: unknown;
  };
}
```

### 7.2 标准化示例

```typescript
// HTTP 请求
{
  title: "用户数据",
  tag: "table",
  data: [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }],
  meta: {
    sourceType: "http",
    source: "https://api.example.com/users",
    rowCount: 2,
    elapsed: 234
  }
}

// CSV 文件
{
  title: "订单数据",
  tag: "table",
  data: [{ id: 1, amount: 100 }, { id: 2, amount: 200 }],
  meta: {
    sourceType: "csv",
    source: "/data/orders.csv",
    rowCount: 2,
    elapsed: 45
  }
}
```

---

## 8. Data Phase 编排

### 8.1 执行流程

```
ExecutableConfig.data[]
  ↓
For each data item:
  1. Detect source type
  2. Get adapter from registry
  3. Validate source config
  4. Fetch data (with retry)
  5. Normalize to DataResult
  ↓
Collect all DataResult
  ↓
Emit event: data_ready
```

### 8.2 并发控制

```typescript
interface DataPhaseOptions {
  concurrency?: number;  // 并发数，默认 3
  timeout?: number;      // 单个数据源超时，默认 60s
  failFast?: boolean;    // 失败是否立即终止，默认 true
}
```

### 8.3 错误处理

| 场景 | failFast=true | failFast=false |
|------|---------------|----------------|
| 单个数据源失败 | 立即终止 | 记录错误，继续其他数据源 |
| 所有数据源失败 | 终止，返回空数组 | 终止，返回空数组 |

---

## 9. 扩展新数据源

### 9.1 实现步骤

1. **实现 DataSourceAdapter 接口**
2. **添加单元测试**
3. **注册到 DataSourceRegistry**
4. **更新 RFC 文档**

### 9.2 示例：FTP 数据源适配器

```typescript
class FtpAdapter implements DataSourceAdapter {
  type = 'ftp';

  async fetch(source: unknown, context: RuntimeContext): Promise<unknown> {
    // 实现 FTP 下载逻辑
  }

  validate(source: unknown): boolean {
    // 验证 FTP 配置
  }

  getMetadata(): AdapterMetadata {
    return {
      type: 'ftp',
      name: 'FTP Data Source Adapter',
      description: 'Fetch data from FTP servers',
      version: '1.0.0',
      supportedFormats: ['json', 'csv', 'txt']
    };
  }
}
```

---

## 10. 测试规范

### 10.1 单元测试要求

每个适配器必须包含以下测试：

| 测试场景 | 覆盖内容 |
|----------|----------|
| 正常流程 | 成功获取数据 |
| 错误处理 | 各种错误类型 |
| 边界条件 | 空数据、大数据 |
| 并发安全 | 多次同时调用 |

### 10.2 集成测试要求

- 真实数据源测试（使用 mock server）
- 端到端场景测试
- 性能测试（大数据量）

---

## 11. 本模块边界声明

本模块 **不负责**：
- 数据的后续处理和转换（由 Enhance 或下游模块负责）
- 数据的可视化展示（由 Render 模块负责）
- 数据的存储和缓存（由 Action 或外部系统负责）

它只负责：
> **定义如何从各种数据源统一、可靠地获取原始数据**
